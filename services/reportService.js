// services/reportService.js - PDF Report Generation
const PDFDocument = require('pdfkit');
const state = require('../state/monitorState');

// Enhanced color palette with modern gradients
const colors = {
  primary: '#6366f1',
  primaryDark: '#4f46e5',
  primaryLight: '#818cf8',
  success: '#10b981',
  successLight: '#34d399',
  warning: '#f59e0b',
  warningLight: '#fbbf24',
  danger: '#ef4444',
  dangerLight: '#f87171',
  dark: '#1a1a24',
  darkGray: '#374151',
  text: '#1f2937',
  textLight: '#4b5563',
  muted: '#6b7280',
  mutedLight: '#9ca3af',
  border: '#e5e7eb',
  borderDark: '#d1d5db',
  background: '#f9fafb',
  backgroundDark: '#f3f4f6',
  white: '#ffffff'
};

// ==================== HELPER FUNCTIONS ====================

const formatDate = (date) => {
  return new Date(date).toLocaleString();
};

const formatDuration = (ms) => {
  if (!ms) return 'N/A';
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  const days = Math.floor(hours / 24);
  
  if (days > 0) return `${days}d ${hours % 24}h`;
  if (hours > 0) return `${hours}h ${minutes % 60}m`;
  if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
  return `${seconds}s`;
};

const drawHeader = (doc, title, subtitle) => {
  // Gradient-like header background with two-tone design
  doc.rect(0, 0, doc.page.width, 120).fill(colors.primary);
  doc.rect(0, 100, doc.page.width, 20).fill(colors.primaryDark);

  // Decorative accent line
  doc.rect(0, 0, doc.page.width, 4).fill(colors.primaryLight);

  // Logo/Brand section with icon placeholder
  doc.save();
  doc.circle(50, 45, 25).fill(colors.white);
  doc.fillColor(colors.primary)
     .fontSize(20)
     .font('Helvetica-Bold')
     .text('P', 43, 32);
  doc.restore();

  // Title
  doc.fillColor(colors.white)
     .fontSize(32)
     .font('Helvetica-Bold')
     .text('PULSE MONITOR', 90, 25);

  // Report type with better styling
  doc.fontSize(13)
     .font('Helvetica')
     .fillColor(colors.primaryLight)
     .text(title, 90, 62);

  // Right side info panel
  const rightX = doc.page.width - 210;

  // Timestamp with icon-style prefix
  doc.fontSize(9)
     .fillColor(colors.white)
     .text('GENERATED', rightX, 30, { width: 180, align: 'right' });
  doc.fontSize(11)
     .font('Helvetica-Bold')
     .text(formatDate(new Date()), rightX, 42, { width: 180, align: 'right' });

  if (subtitle) {
    doc.fontSize(10)
       .font('Helvetica')
       .fillColor(colors.primaryLight)
       .text(subtitle, rightX, 62, { width: 180, align: 'right' });
  }

  doc.fillColor(colors.text);
  doc.y = 140;
};

const drawFooter = (doc) => {
  const pageHeight = doc.page.height;
  const pageWidth = doc.page.width;

  // Footer background
  doc.rect(0, pageHeight - 50, pageWidth, 50).fill(colors.backgroundDark);

  // Divider line
  doc.moveTo(0, pageHeight - 50)
     .lineTo(pageWidth, pageHeight - 50)
     .stroke(colors.border);

  // Page number
  const pageNumber = doc.bufferedPageRange().count;
  doc.fontSize(9)
     .fillColor(colors.muted)
     .text(`Page ${pageNumber}`, 50, pageHeight - 30, { width: 100, align: 'left' });

  // Footer text
  doc.fontSize(8)
     .fillColor(colors.mutedLight)
     .text('Generated by Pulse Monitor v4.0.0', 0, pageHeight - 30, { width: pageWidth - 50, align: 'right' });
};

const drawSectionTitle = (doc, title, subtitle = null) => {
  doc.moveDown(0.8);

  // Background accent bar
  doc.rect(45, doc.y, 5, 20).fill(colors.primary);

  // Title
  doc.fontSize(18)
     .font('Helvetica-Bold')
     .fillColor(colors.text)
     .text(title, 58, doc.y);

  if (subtitle) {
    doc.fontSize(10)
       .font('Helvetica')
       .fillColor(colors.muted)
       .text(subtitle, 58, doc.y + 20);
  }

  doc.moveDown(0.5);

  // Subtle divider line
  doc.moveTo(50, doc.y)
     .lineTo(doc.page.width - 50, doc.y)
     .stroke(colors.border);

  doc.moveDown(0.5);
  doc.fillColor(colors.text).font('Helvetica');
};

const drawStatusBadge = (doc, x, y, status, width = 70) => {
  const color = status === 'UP' ? colors.success :
                status === 'DOWN' ? colors.danger : colors.warning;

  // Shadow effect
  doc.roundedRect(x + 2, y + 2, width, 24, 5).fill('#00000010');

  // Badge background
  doc.roundedRect(x, y, width, 24, 5).fill(color);

  // Status text
  doc.fillColor(colors.white)
     .fontSize(10)
     .font('Helvetica-Bold')
     .text(status, x, y + 7, { width, align: 'center' });
  doc.fillColor(colors.text).font('Helvetica');
};

const drawProgressBar = (doc, x, y, width, percentage, color = colors.success) => {
  const height = 16;
  const radius = 8;

  // Background with border
  doc.roundedRect(x, y, width, height, radius)
     .fill(colors.backgroundDark);
  doc.roundedRect(x, y, width, height, radius)
     .lineWidth(1)
     .stroke(colors.border);

  // Fill with percentage
  const fillWidth = Math.max(0, Math.min(percentage, 100)) / 100 * width;
  if (fillWidth > radius * 2) {
    doc.roundedRect(x, y, fillWidth, height, radius).fill(color);
  }

  // Percentage text overlay
  doc.fillColor(colors.white)
     .fontSize(9)
     .font('Helvetica-Bold')
     .text(`${Math.round(percentage)}%`, x, y + 3, { width, align: 'center' });

  doc.fillColor(colors.text).font('Helvetica');
};

// Helper to draw modern metric cards
const drawMetricCard = (doc, x, y, label, value, color) => {
  const cardWidth = 100;
  const cardHeight = 85;

  // Card shadow
  doc.roundedRect(x + 3, y + 3, cardWidth, cardHeight, 8).fill('#00000008');

  // Card background with border
  doc.roundedRect(x, y, cardWidth, cardHeight, 8).fill(colors.white);
  doc.roundedRect(x, y, cardWidth, cardHeight, 8)
     .lineWidth(1)
     .stroke(colors.border);

  // Color accent bar at top
  doc.roundedRect(x, y, cardWidth, 4, 8).fill(color);

  // Value
  doc.fillColor(color)
     .fontSize(28)
     .font('Helvetica-Bold')
     .text(value.toString(), x, y + 20, { width: cardWidth, align: 'center' });

  // Label
  doc.fillColor(colors.textLight)
     .fontSize(9)
     .font('Helvetica')
     .text(label.toUpperCase(), x, y + 58, { width: cardWidth, align: 'center' });

  doc.fillColor(colors.text);
};

// ==================== REPORT: OVERVIEW ====================

const generateOverviewReport = (doc) => {
  const stats = state.getStats();
  const monitors = state.getAllMonitors();
  const applications = state.getAllApplications();
  const statuses = state.getAllStatuses();

  drawHeader(doc, 'System Overview Report', `${monitors.length} Monitors`);

  // Summary Cards
  drawSectionTitle(doc, 'System Summary', 'Key metrics at a glance');

  const cardY = doc.y;
  const cardSpacing = 10;

  // Draw summary cards with modern design
  const cards = [
    { label: 'Total Monitors', value: stats.monitors.total, color: colors.primary },
    { label: 'Online', value: stats.monitors.up, color: colors.success },
    { label: 'Offline', value: stats.monitors.down, color: colors.danger },
    { label: 'Applications', value: stats.applications.total, color: colors.primaryDark },
    { label: 'Active Alerts', value: stats.alerts.active, color: stats.alerts.active > 0 ? colors.warning : colors.success }
  ];

  cards.forEach((card, i) => {
    const x = 50 + (i * (100 + cardSpacing));
    drawMetricCard(doc, x, cardY, card.label, card.value, card.color);
  });

  doc.y = cardY + 105;
  doc.fillColor(colors.text);
  
  // Uptime Section with visual enhancement
  drawSectionTitle(doc, 'Overall System Uptime', 'Aggregate uptime across all monitors');

  const uptimeY = doc.y;

  // Uptime percentage display
  doc.fontSize(42)
     .font('Helvetica-Bold')
     .fillColor(stats.uptime >= 99 ? colors.success : stats.uptime >= 95 ? colors.warning : colors.danger)
     .text(`${stats.uptime.toFixed(2)}%`, 50, uptimeY, { width: 150, align: 'left' });

  doc.fontSize(11)
     .font('Helvetica')
     .fillColor(colors.muted)
     .text('System Uptime', 50, uptimeY + 52);

  // Progress bar
  const uptimeColor = stats.uptime >= 99 ? colors.success :
                      stats.uptime >= 95 ? colors.warning : colors.danger;
  drawProgressBar(doc, 220, uptimeY + 15, 330, stats.uptime, uptimeColor);

  doc.y = uptimeY + 85;
  doc.fillColor(colors.text);
  
  // Applications Health
  if (applications.length > 0) {
    drawSectionTitle(doc, 'Applications Health', 'Health status of all applications');

    applications.forEach((app, index) => {
      const health = state.getApplicationHealth(app.id);
      if (health) {
        const rowY = doc.y;
        const rowHeight = 50;

        // Alternating row background
        if (index % 2 === 0) {
          doc.roundedRect(45, rowY, doc.page.width - 90, rowHeight, 4).fill(colors.background);
        }

        // App name
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .fillColor(colors.text)
           .text(app.name, 60, rowY + 8);

        // Health badge
        const statusX = 280;
        const healthStatus = health.health === 'healthy' ? 'HEALTHY' :
                           health.health === 'critical' ? 'CRITICAL' : 'WARNING';
        drawStatusBadge(doc, statusX, rowY + 8, healthStatus, 85);

        // Components info
        doc.font('Helvetica')
           .fontSize(9)
           .fillColor(colors.textLight)
           .text(`${health.up} / ${health.total} components`, 380, rowY + 14);

        // Uptime bar
        const progressY = rowY + 32;
        drawProgressBar(doc, 60, progressY, 200, health.uptime,
          health.health === 'healthy' ? colors.success : colors.danger);

        doc.y = rowY + rowHeight + 5;
        doc.fillColor(colors.text);
      }
    });

    doc.moveDown(0.5);
  }
  
  // Monitor Status List with table design
  drawSectionTitle(doc, 'Monitor Status', `Detailed status of ${monitors.length} monitors`);

  // Table header
  const tableY = doc.y;
  const tableWidth = doc.page.width - 100;

  // Header background
  doc.roundedRect(50, tableY, tableWidth, 28, 4).fill(colors.primaryDark);

  // Header text
  doc.fontSize(9)
     .font('Helvetica-Bold')
     .fillColor(colors.white)
     .text('MONITOR NAME', 60, tableY + 9, { width: 180 })
     .text('STATUS', 265, tableY + 9, { width: 70 })
     .text('TYPE', 350, tableY + 9, { width: 60 })
     .text('RESPONSE', 420, tableY + 9, { width: 50 })
     .text('LAST CHECK', 480, tableY + 9, { width: 80 });

  doc.y = tableY + 35;

  monitors.forEach((monitor, index) => {
    if (doc.y > doc.page.height - 120) {
      doc.addPage();
      drawFooter(doc);
      doc.y = 50;
    }

    const status = statuses[monitor.id];
    const statusText = status?.status || 'PENDING';
    const rowY = doc.y;
    const rowHeight = 36;

    // Alternating row background
    if (index % 2 === 0) {
      doc.roundedRect(50, rowY, tableWidth, rowHeight, 4).fill(colors.background);
    }

    // Monitor name
    doc.fontSize(10)
       .font('Helvetica-Bold')
       .fillColor(colors.text)
       .text(monitor.name, 60, rowY + 11, { width: 180, ellipsis: true });

    // Status badge
    drawStatusBadge(doc, 260, rowY + 6, statusText, 75);

    // Type, response time, last check
    doc.font('Helvetica')
       .fontSize(9)
       .fillColor(colors.textLight)
       .text(monitor.type?.toUpperCase() || 'N/A', 350, rowY + 13)
       .text(status?.responseTime ? `${status.responseTime}ms` : '-', 420, rowY + 13)
       .text(status?.lastCheck ? formatDate(status.lastCheck).split(',')[1]?.trim() : 'Never', 480, rowY + 13, { width: 80 });

    doc.y = rowY + rowHeight;
    doc.fillColor(colors.text);
  });

  // Add footer to first page
  drawFooter(doc);
};

// ==================== REPORT: APPLICATION ====================

const generateApplicationReport = (doc, applicationId) => {
  const app = state.getApplication(applicationId);
  if (!app) {
    doc.text('Application not found');
    return;
  }

  const health = state.getApplicationHealth(applicationId);
  const monitors = state.getMonitorsByApplication(applicationId);
  const statuses = state.getAllStatuses();

  drawHeader(doc, 'Application Report', app.name);

  // Application Info Card
  drawSectionTitle(doc, 'Application Overview', 'Basic information and metadata');

  const infoY = doc.y;
  const cardWidth = doc.page.width - 100;

  // Info card background
  doc.roundedRect(50, infoY, cardWidth, 110, 8).fill(colors.background);
  doc.roundedRect(50, infoY, cardWidth, 110, 8)
     .lineWidth(1)
     .stroke(colors.border);

  // Application name (large)
  doc.fontSize(18)
     .font('Helvetica-Bold')
     .fillColor(colors.text)
     .text(app.name, 70, infoY + 15);

  // Description
  doc.fontSize(10)
     .font('Helvetica')
     .fillColor(colors.textLight)
     .text(app.description || 'No description provided', 70, infoY + 45, { width: cardWidth - 40 });

  // Metadata row
  doc.fontSize(9)
     .fillColor(colors.muted)
     .text(`Components: ${monitors.length}`, 70, infoY + 75)
     .text(`Created: ${formatDate(app.createdAt)}`, 250, infoY + 75);

  doc.y = infoY + 125;

  // Health Status Card
  drawSectionTitle(doc, 'Health Status', 'Current application health metrics');

  const healthY = doc.y;
  const healthColor = health.health === 'healthy' ? colors.success :
                      health.health === 'critical' ? colors.danger : colors.warning;

  // Health card
  doc.roundedRect(50, healthY, 180, 90, 8).fill(healthColor);

  // Health status icon/text
  doc.fillColor(colors.white)
     .fontSize(24)
     .font('Helvetica-Bold')
     .text(health.health.toUpperCase(), 50, healthY + 20, { width: 180, align: 'center' });

  doc.fontSize(12)
     .font('Helvetica')
     .text(`${health.up} / ${health.total} Up`, 50, healthY + 55, { width: 180, align: 'center' });

  // Uptime metrics
  doc.fontSize(10)
     .fillColor(colors.text)
     .font('Helvetica-Bold')
     .text('Overall Uptime', 250, healthY + 15);

  drawProgressBar(doc, 250, healthY + 40, 280, health.uptime, healthColor);

  doc.y = healthY + 105;
  
  // Component List with enhanced styling
  drawSectionTitle(doc, 'Components', `${monitors.length} monitors in this application`);

  monitors.forEach((monitor) => {
    if (doc.y > doc.page.height - 120) {
      doc.addPage();
      drawFooter(doc);
      doc.y = 50;
    }

    const status = statuses[monitor.id];
    const componentY = doc.y;
    const componentHeight = 65;

    // Component card
    doc.roundedRect(48, componentY + 2, doc.page.width - 96, componentHeight, 6).fill('#00000004');
    doc.roundedRect(45, componentY, doc.page.width - 90, componentHeight, 6).fill(colors.white);
    doc.roundedRect(45, componentY, doc.page.width - 90, componentHeight, 6)
       .lineWidth(1)
       .stroke(colors.border);

    // Status indicator
    const statusColor = status?.status === 'UP' ? colors.success :
                       status?.status === 'DOWN' ? colors.danger : colors.warning;
    doc.roundedRect(45, componentY, 5, componentHeight, 6).fill(statusColor);

    // Monitor name
    doc.fontSize(12)
       .font('Helvetica-Bold')
       .fillColor(colors.text)
       .text(monitor.name, 65, componentY + 12);

    // Status badge
    drawStatusBadge(doc, doc.page.width - 160, componentY + 10, status?.status || 'PENDING', 85);

    // Component details
    const detailsY = componentY + 38;
    doc.fontSize(9)
       .font('Helvetica')
       .fillColor(colors.textLight)
       .text(`Type: ${monitor.type?.toUpperCase()}`, 65, detailsY)
       .text(`Response: ${status?.responseTime || '-'}ms`, 180, detailsY)
       .text(`Last Check: ${status?.lastCheck ? formatDate(status.lastCheck) : 'Never'}`, 300, detailsY);

    doc.y = componentY + componentHeight + 10;
    doc.fillColor(colors.text);
  });

  drawFooter(doc);
};

// ==================== REPORT: INCIDENTS ====================

const generateIncidentReport = (doc, options = {}) => {
  const incidents = state.getIncidents(options.limit || 50);
  
  drawHeader(doc, 'Incident Report', `${incidents.length} Incidents`);

  if (incidents.length === 0) {
    doc.fontSize(12)
       .fillColor(colors.muted)
       .text('No incidents recorded.', 50, 200, { align: 'center' });
    drawFooter(doc);
    return;
  }

  // Summary Cards
  drawSectionTitle(doc, 'Incident Summary', 'Overview of incident metrics');

  const ongoing = incidents.filter(i => i.status === 'ongoing').length;
  const resolved = incidents.filter(i => i.status === 'resolved').length;
  const avgDuration = resolved > 0
    ? incidents.filter(i => i.duration).reduce((sum, i) => sum + i.duration, 0) / resolved
    : 0;

  const summaryY = doc.y;
  drawMetricCard(doc, 50, summaryY, 'Total', incidents.length, colors.primary);
  drawMetricCard(doc, 165, summaryY, 'Ongoing', ongoing, colors.danger);
  drawMetricCard(doc, 280, summaryY, 'Resolved', resolved, colors.success);

  // Average duration display
  doc.fontSize(10)
     .font('Helvetica')
     .fillColor(colors.muted)
     .text('AVG DURATION', 400, summaryY + 20);
  doc.fontSize(18)
     .font('Helvetica-Bold')
     .fillColor(colors.text)
     .text(formatDuration(avgDuration), 400, summaryY + 38);

  doc.y = summaryY + 120;
  doc.fillColor(colors.text);
  
  // Incident List with enhanced design
  drawSectionTitle(doc, 'Incident History', 'Recent incidents and their resolution status');

  incidents.forEach(incident => {
    if (doc.y > doc.page.height - 160) {
      doc.addPage();
      drawFooter(doc);
      doc.y = 50;
    }

    const cardY = doc.y;
    const cardHeight = 110;
    const cardWidth = doc.page.width - 100;

    // Card shadow
    doc.roundedRect(53, cardY + 3, cardWidth, cardHeight, 8).fill('#00000006');

    // Card background
    doc.roundedRect(50, cardY, cardWidth, cardHeight, 8).fill(colors.white);
    doc.roundedRect(50, cardY, cardWidth, cardHeight, 8)
       .lineWidth(1)
       .stroke(colors.border);

    // Status indicator bar on left
    const statusColor = incident.status === 'ongoing' ? colors.danger : colors.success;
    doc.roundedRect(50, cardY, 6, cardHeight, 8).fill(statusColor);

    // Monitor name
    doc.fillColor(colors.text)
       .fontSize(13)
       .font('Helvetica-Bold')
       .text(incident.monitorName, 70, cardY + 12, { width: 320 });

    // Status badge
    drawStatusBadge(doc, cardWidth - 30, cardY + 10, incident.status.toUpperCase(), 90);

    // Incident details with icons/labels
    const detailsY = cardY + 42;
    doc.fontSize(8)
       .font('Helvetica')
       .fillColor(colors.mutedLight)
       .text('STARTED', 70, detailsY)
       .text('DURATION', 70, detailsY + 18)
       .text('MESSAGE', 70, detailsY + 36);

    doc.fontSize(9)
       .fillColor(colors.textLight)
       .text(formatDate(incident.startedAt), 130, detailsY)
       .text(formatDuration(incident.duration), 130, detailsY + 18)
       .text(incident.message, 130, detailsY + 36, { width: cardWidth - 180 });

    // Resolved timestamp if applicable
    if (incident.resolvedAt) {
      doc.fontSize(8)
         .fillColor(colors.mutedLight)
         .text('RESOLVED', 320, detailsY);
      doc.fontSize(9)
         .fillColor(colors.success)
         .text(formatDate(incident.resolvedAt), 380, detailsY);
    }

    doc.y = cardY + cardHeight + 12;
  });

  drawFooter(doc);
};

// ==================== REPORT: ALERTS ====================

const generateAlertReport = (doc, options = {}) => {
  const alerts = options.activeOnly ? state.getActiveAlerts() : state.getAllAlerts();
  
  drawHeader(doc, options.activeOnly ? 'Active Alerts Report' : 'Alerts Report', `${alerts.length} Alerts`);

  if (alerts.length === 0) {
    doc.fontSize(12)
       .fillColor(colors.muted)
       .text('No alerts recorded.', 50, 200, { align: 'center' });
    drawFooter(doc);
    return;
  }

  // Summary Cards
  drawSectionTitle(doc, 'Alert Summary', 'Overview of alert status and severity');

  const active = alerts.filter(a => a.status === 'active').length;
  const acknowledged = alerts.filter(a => a.status === 'acknowledged').length;
  const resolved = alerts.filter(a => a.status === 'resolved').length;
  const critical = alerts.filter(a => a.severity === 'critical').length;

  const summaryY = doc.y;
  drawMetricCard(doc, 50, summaryY, 'Active', active, colors.danger);
  drawMetricCard(doc, 165, summaryY, 'Acknowledged', acknowledged, colors.warning);
  drawMetricCard(doc, 280, summaryY, 'Resolved', resolved, colors.success);
  drawMetricCard(doc, 395, summaryY, 'Critical', critical, colors.dangerLight);

  doc.y = summaryY + 110;
  doc.fillColor(colors.text);
  
  // Alert List with enhanced design
  drawSectionTitle(doc, 'Alert History', 'Active and resolved alerts');

  alerts.slice(0, 50).forEach((alert, index) => {
    if (doc.y > doc.page.height - 110) {
      doc.addPage();
      drawFooter(doc);
      doc.y = 50;
    }

    const alertY = doc.y;
    const alertHeight = 75;
    const severityColor = alert.severity === 'critical' ? colors.danger : colors.warning;

    // Alert card background
    if (index % 2 === 0) {
      doc.roundedRect(45, alertY, doc.page.width - 90, alertHeight, 6).fill(colors.background);
    }

    // Severity indicator bar on left
    doc.roundedRect(50, alertY + 8, 5, alertHeight - 16, 3).fill(severityColor);

    // Monitor name
    doc.fillColor(colors.text)
       .fontSize(12)
       .font('Helvetica-Bold')
       .text(alert.monitorName, 70, alertY + 10, { width: 280 });

    // Severity badge
    const severityText = alert.severity === 'critical' ? 'CRITICAL' : 'WARNING';
    drawStatusBadge(doc, 360, alertY + 8, severityText, 85);

    // Alert metadata
    doc.font('Helvetica')
       .fontSize(9)
       .fillColor(colors.textLight)
       .text(`${alert.type} â€¢ ${alert.status}`, 70, alertY + 32);

    // Timestamp
    doc.fontSize(8)
       .fillColor(colors.muted)
       .text(formatDate(alert.createdAt), 70, alertY + 48);

    // Message
    doc.fillColor(colors.text)
       .fontSize(9)
       .text(alert.message, 200, alertY + 48, { width: doc.page.width - 260, ellipsis: true });

    doc.y = alertY + alertHeight + 4;
  });

  drawFooter(doc);
};

// ==================== REPORT: ACTIVITY LOG ====================

const generateActivityReport = (doc, options = {}) => {
  const activities = state.getActivityLogs({ limit: options.limit || 100 });
  
  drawHeader(doc, 'Activity Log Report', `${activities.length} Activities`);

  if (activities.length === 0) {
    doc.fontSize(12)
       .fillColor(colors.muted)
       .text('No activities recorded.', 50, 200, { align: 'center' });
    drawFooter(doc);
    return;
  }
  
  // Activity List with timeline design
  drawSectionTitle(doc, 'Recent Activities', 'Chronological activity log');

  activities.forEach((activity, index) => {
    if (doc.y > doc.page.height - 80) {
      doc.addPage();
      drawFooter(doc);
      doc.y = 50;
    }

    const activityY = doc.y;

    // Timeline dot and line
    doc.circle(58, activityY + 8, 4).fill(colors.primary);
    if (index < activities.length - 1) {
      doc.moveTo(58, activityY + 12)
         .lineTo(58, activityY + 32)
         .lineWidth(2)
         .stroke(colors.border);
    }

    // Activity row background
    if (index % 2 === 0) {
      doc.roundedRect(70, activityY, doc.page.width - 120, 28, 4).fill(colors.background);
    }

    // Timestamp
    doc.fontSize(8)
       .fillColor(colors.muted)
       .font('Helvetica')
       .text(formatDate(activity.timestamp), 80, activityY + 5, { width: 130 });

    // Action badge
    doc.roundedRect(220, activityY + 3, 80, 18, 3).fill(colors.primaryLight);
    doc.fontSize(8)
       .fillColor(colors.white)
       .font('Helvetica-Bold')
       .text(activity.action.toUpperCase(), 220, activityY + 7, { width: 80, align: 'center' });

    // Entity info
    doc.fillColor(colors.text)
       .fontSize(9)
       .font('Helvetica')
       .text(`${activity.entityType}: `, 310, activityY + 9)
       .font('Helvetica-Bold')
       .text(activity.entityName, 310 + doc.widthOfString(`${activity.entityType}: `), activityY + 9, { width: 200 });

    doc.y = activityY + 32;
    doc.fillColor(colors.text).font('Helvetica');
  });

  drawFooter(doc);
};

// ==================== REPORT: UPTIME ====================

const generateUptimeReport = (doc, options = {}) => {
  const monitors = state.getAllMonitors();
  const statuses = state.getAllStatuses();
  
  drawHeader(doc, 'Uptime Report', `${monitors.length} Monitors`);
  
  // Summary with visual card
  drawSectionTitle(doc, 'Uptime Summary', 'System-wide uptime statistics');

  let totalUptime = 0;
  const uptimeData = monitors.map(monitor => {
    const status = statuses[monitor.id];
    const uptime = status?.totalChecks > 0
      ? Math.round((status.successfulChecks / status.totalChecks) * 100)
      : 0;
    totalUptime += uptime;
    return { monitor, status, uptime };
  });

  const avgUptime = monitors.length > 0 ? totalUptime / monitors.length : 0;
  const summaryY = doc.y;

  // Average uptime card
  doc.roundedRect(50, summaryY, 250, 80, 8).fill(colors.success);
  doc.fontSize(14)
     .font('Helvetica')
     .fillColor(colors.white)
     .text('AVERAGE UPTIME', 50, summaryY + 15, { width: 250, align: 'center' });
  doc.fontSize(36)
     .font('Helvetica-Bold')
     .text(`${avgUptime.toFixed(1)}%`, 50, summaryY + 35, { width: 250, align: 'center' });

  // Monitor count
  doc.fontSize(10)
     .font('Helvetica')
     .fillColor(colors.text)
     .text(`Total Monitors: ${monitors.length}`, 320, summaryY + 30);

  doc.y = summaryY + 100;
  
  // Per-monitor uptime with enhanced layout
  drawSectionTitle(doc, 'Monitor Uptime', 'Individual monitor reliability metrics');

  uptimeData.sort((a, b) => b.uptime - a.uptime).forEach(({ monitor, status, uptime }, index) => {
    if (doc.y > doc.page.height - 70) {
      doc.addPage();
      drawFooter(doc);
      doc.y = 50;
    }

    const rowY = doc.y;
    const rowHeight = 42;

    // Alternating row background
    if (index % 2 === 0) {
      doc.roundedRect(45, rowY, doc.page.width - 90, rowHeight, 5).fill(colors.background);
    }

    // Monitor name
    doc.fontSize(11)
       .font('Helvetica-Bold')
       .fillColor(colors.text)
       .text(monitor.name, 60, rowY + 8, { width: 200, ellipsis: true });

    // Uptime percentage (large)
    const uptimeColor = uptime >= 99 ? colors.success :
                        uptime >= 95 ? colors.warning : colors.danger;

    doc.fontSize(16)
       .fillColor(uptimeColor)
       .text(`${uptime.toFixed(1)}%`, 270, rowY + 10);

    // Progress bar
    drawProgressBar(doc, 340, rowY + 13, 150, uptime, uptimeColor);

    // Checks count
    doc.font('Helvetica')
       .fontSize(8)
       .fillColor(colors.muted)
       .text(`${status?.totalChecks || 0} checks`, 500, rowY + 18);

    doc.y = rowY + rowHeight;
    doc.fillColor(colors.text);
  });

  drawFooter(doc);
};

// ==================== MAIN GENERATION FUNCTION ====================

const generateReport = (type, options = {}) => {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'A4',
        margin: 50,
        info: {
          Title: `Pulse Monitor - ${type} Report`,
          Author: 'Pulse Monitor v4.0.0',
          Creator: 'Pulse Monitor'
        }
      });
      
      const chunks = [];
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);
      
      switch (type) {
        case 'overview':
          generateOverviewReport(doc);
          break;
        case 'application':
          generateApplicationReport(doc, options.applicationId);
          break;
        case 'incidents':
          generateIncidentReport(doc, options);
          break;
        case 'alerts':
          generateAlertReport(doc, options);
          break;
        case 'activity':
          generateActivityReport(doc, options);
          break;
        case 'uptime':
          generateUptimeReport(doc, options);
          break;
        default:
          generateOverviewReport(doc);
      }
      
      doc.end();
    } catch (error) {
      reject(error);
    }
  });
};

module.exports = {
  generateReport
};
